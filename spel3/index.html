<!DOCTYPE html>
<html lang="sv">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>üè∞ Rybergs Slott 9x9</title>
<style>
body{
    margin:0;
    font-family: Arial, sans-serif;
    background: radial-gradient(circle,#1a0033,#000);
    color:white;
    display:flex;
    justify-content:center;
    align-items:center;
    height:100vh;
}
.wrapper{
    text-align:center;
    background:#111;
    padding:20px;
    border-radius:20px;
    box-shadow:0 0 30px #ff00cc;
}
h1{
    color:#ffd700;
    text-shadow:0 0 15px #ffd700;
    margin-bottom:10px;
}
#grid{
    display:grid;
    grid-template-columns: repeat(9, 50px);
    grid-template-rows: repeat(9, 50px);
    gap:5px;
    justify-content:center;
    margin:20px 0;
}
.cell{
    width:50px;
    height:50px;
    background:#222;
    border-radius:8px;
    display:flex;
    justify-content:center;
    align-items:center;
    font-size:28px;
    transition: all 0.2s ease;
}
button{
    padding:10px 20px;
    margin:5px;
    border:none;
    border-radius:10px;
    font-weight:bold;
    cursor:pointer;
}
.spin{background:#00ffe7;}
.home{background:#ff5555;}
.stats{
    margin-top:10px;
}
</style>
</head>
<body>
<div class="wrapper">
    <h1>üè∞ Rybergs Slott 9x9</h1>
    <div id="grid"></div>
    <button class="spin" onclick="spin()">üé∞ Snurra</button>
    <button class="home" onclick="goHome()">‚Üê Tillbaka</button>
    <div class="stats">
        Po√§ng: <span id="score">0</span> |
        Highscore: <span id="highscore">0</span>
    </div>
</div>

<script>
const gridSize = 9;
const symbols = ["üíé","üëë","üçÄ","‚≠ê","üó°Ô∏è","üè∞"];
let grid = [];
const gridEl = document.getElementById("grid");
const scoreEl = document.getElementById("score");
const highEl = document.getElementById("highscore");
let score = 0;
let highscore = parseInt(localStorage.getItem("slotHigh")) || 0;
highEl.textContent = highscore;

// Initialize grid
function initGrid(){
    gridEl.innerHTML="";
    grid=[];
    for(let r=0;r<gridSize;r++){
        grid[r]=[];
        for(let c=0;c<gridSize;c++){
            let sym = symbols[Math.floor(Math.random()*symbols.length)];
            grid[r][c] = sym;
            const cell = document.createElement("div");
            cell.className="cell";
            cell.dataset.row=r;
            cell.dataset.col=c;
            cell.textContent="";
            gridEl.appendChild(cell);
        }
    }
}

// Animate falling symbols
function dropSymbols(callback){
    let maxDrop = 0;
    for(let c=0;c<gridSize;c++){
        let col=[]; 
        for(let r=0;r<gridSize;r++){
            if(grid[r][c]==="") col.push(r);
        }
        if(col.length>maxDrop) maxDrop=col.length;
    }
    let step = 0;
    function stepDrop(){
        for(let r=gridSize-1;r>=0;r--){
            for(let c=0;c<gridSize;c++){
                if(grid[r][c]===""){
                    // fall from above
                    for(let rr=r-1;rr>=0;rr--){
                        if(grid[rr][c]!==""){
                            grid[r][c]=grid[rr][c];
                            grid[rr][c]="";
                            break;
                        }
                    }
                }
            }
        }
        renderGrid();
        step++;
        if(step<maxDrop+1) requestAnimationFrame(stepDrop);
        else callback();
    }
    stepDrop();
}

function renderGrid(){
    const cells = document.querySelectorAll(".cell");
    cells.forEach(cell=>{
        let r = parseInt(cell.dataset.row);
        let c = parseInt(cell.dataset.col);
        cell.textContent = grid[r][c];
    });
}

// Check matches (horizontal, vertical, diagonal)
function checkMatches(){
    let matches=[];
    // horizontal
    for(let r=0;r<gridSize;r++){
        for(let c=0;c<gridSize-2;c++){
            if(grid[r][c]!=="" && grid[r][c]===grid[r][c+1] && grid[r][c]===grid[r][c+2]){
                matches.push([r,c],[r,c+1],[r,c+2]);
            }
        }
    }
    // vertical
    for(let c=0;c<gridSize;c++){
        for(let r=0;r<gridSize-2;r++){
            if(grid[r][c]!=="" && grid[r][c]===grid[r+1][c] && grid[r][c]===grid[r+2][c]){
                matches.push([r,c],[r+1,c],[r+2,c]);
            }
        }
    }
    // diagonal
    for(let r=0;r<gridSize-2;r++){
        for(let c=0;c<gridSize-2;c++){
            if(grid[r][c]!=="" && grid[r][c]===grid[r+1][c+1] && grid[r][c]===grid[r+2][c+2]){
                matches.push([r,c],[r+1,c+1],[r+2,c+2]);
            }
            if(grid[r+2][c]!=="" && grid[r+2][c]===grid[r+1][c+1] && grid[r+2][c]===grid[r][c+2]){
                matches.push([r+2,c],[r+1,c+1],[r,c+2]);
            }
        }
    }
    // remove duplicates
    let unique = matches.map(JSON.stringify)
                        .filter((v,i,a)=>a.indexOf(v)===i)
                        .map(JSON.parse);
    return unique;
}

// Spin function
function spin(){
    // Fill empty cells with random symbols
    for(let r=0;r<gridSize;r++){
        for(let c=0;c<gridSize;c++){
            if(grid[r][c]==="") grid[r][c]=symbols[Math.floor(Math.random()*symbols.length)];
        }
    }
    dropSymbols(()=>{
        let matches = checkMatches();
        let points = matches.length*10;
        score+=points;
        scoreEl.textContent = score;
        if(score>highscore){
            highscore=score;
            highEl.textContent=highscore;
            localStorage.setItem("slotHigh",highscore);
        }
        // Remove matched symbols
        matches.forEach(([r,c])=>grid[r][c]="");
        if(matches.length>0){
            // animate falling again for new symbols
            setTimeout(spin,200);
        }
        renderGrid();
    });
}

function goHome(){
    window.location.href="../index.html";
}

// Initialize
initGrid();
renderGrid();
</script>
</body>
</html>
